function [ Xout ] = SimpleRobotPlotROS( u )
%SIMPLEROBOTPLOT Summary of this function goes here
persistent  jointpub jointmsg counter tftree tfStampedMsg tfStampedMsg1 tfStampedMsg2 tfStampedMsg3
persistent  tfStampedMsgcm1 tfStampedMsgcm2 tfStampedMsgcm3

%Joint Position
q1=u(1);
q2=u(2);
q3=u(3);

%Joint Velocity
qp1=u(4);
qp2=u(5);
qp3=u(6);

%Kinematic Parameters
L1=u(7);
L2=u(8);
L4=u(9);
L6=u(10);
L7=u(11);
L9=u(12);
L3=u(13);
L5=u(14);
L8=u(15);
L10=u(16);

%Time
t=u(x);

% THETA ALPHA a d
DH = [q1, -pi/2, 0, L1;
    q2+pi/2, pi, -L3, L2;
    q3, 0, -L5, 0;
    q1, 0, 0, L6; % CM1
    q2+pi/2, 0, -L8, L7; % CM2
    q3, 0, -L10, 0.5*L7]; % CM3

% Specify the Robot Base (with respect to the world coordinate frame in ROS)
T0_W=eye(4);

% Compute the Homogeneous Transformations

T1_0= Relative_H(DH(1,:));

T2_1= Relative_H(DH(2,:));

T3_2= Relative_H(DH(3,:));

Tcm1_0= Relative_H(DH(4,:));

Tcm2_1= Relative_H(DH(5,:));

Tcm3_2= Relative_H(DH(6,:));

% Stack of Transformations
%T1_0=0;
T2_0= T1_0*T2_1;
T3_0= T2_0*T3_2;

%Tcm1_0=0;
Tcm2_0= T1_0*Tcm2_1;
Tcm3_0= T2_0*Tcm3_2;

T1_W= T1_0;
T2_W= T2_0;
T3_W= T3_0;

Tcm1_W= Tcm1_0;
Tcm2_W= Tcm2_0;
Tcm3_W= Tcm3_0;

% Get the position of the end-effector
Xef_W=T3_W(1:3,4);

%Initialize the publishers and messages

%Publish the robot joints and tf's (Base, Links, CMs and EF), see the joint names generated by bringUR10.launch


% Output: vector [Xef] (size 3X1)
Xout=[Xef_W(1:3)];




end

